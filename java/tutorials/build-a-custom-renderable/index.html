<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="description" content="NASA WorldWind Software Development Kits (SDKs) for geo-spatial 3D virtual
        globe visualization via OpenGL/WebGL on Android, Java and JavaScript/HTML5 platforms.">
        <link rel="icon" href="/img/favicon.ico" type="image/x-icon"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
        <link href="https://fonts.googleapis.com/css?family=Lato:300" rel="stylesheet">
        <link rel="stylesheet" href="/css/theme.css">
        <title>
            Build a Custom Renderable-WorldWind Java/NASA WorldWind
        </title>
        
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105294289-1', 'auto');
    ga('send', 'pageview');

</script>

    </head>

    <body>
    <div class='wrapper'>
    <div>
        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container-fluid">
                <p class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#myNavBar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="/" class="navbar-brand"><img id="logo-size" src="/img/nasa-logo.svg" alt="Blue NASA Meatball"></a>
                    <a href="/" class="navbar-brand" id="webww-header">NASA WorldWind</a>
                <div id="myNavBar" class="navbar-collapse collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="/about">About</a></li>
                        <li><a href="/web">Web</a></li>
                        <li><a href="/android">Android</a></li>
                        <li><a href="/java">Java</a></li>
                        <li><a href="/serverkit">Server Kit</a></li>
                        <li><a href="/contact">Contact</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </div>

        
<div class="container-fluid">
    <div class="row ww-carousel">
        <div id="myCarousel" class="carousel slide carousel-fade" data-ride="carousel">
            
            <div class="carousel-inner">
                <div class="item active">
                    <img src="/img/java-background.jpg" alt="" style="width:100%;">
                    <div class="jumbotron-overlay"></div>
                    <div class="heading">
                        <h1>WorldWind Java</h1>
                    </div>
                </div>

                <div class="item">
                    <img src="/img/serverkit-background.jpg" alt="" style="width:100%;">
                    <div class="jumbotron-overlay"></div>
                    <div class="heading">
                        <h1>WorldWind Java</h1>
                    </div>
                </div>

                <div class="item">
                    <img src="/img/web-background.jpg" alt="" style="width:100%;">
                    <div class="jumbotron-overlay"></div>
                    <div class="heading">
                        <h1>WorldWind Java</h1>
                    </div>
                </div>

                <div class="item">
                    <img src="/img/android-background.jpg" alt="" style="width:100%;">
                    <div class="jumbotron-overlay"></div>
                    <div class="heading">
                        <h1>WorldWind Java</h1>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="anchor"></div>
<a href="https://github.com/NASAWorldWind/WorldWindJava"><img style="position: absolute; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
<div id="menu" style="display: none;"></div>
<div class="container content-container" id="main">
    <div class="row-fluid" style="margin-bottom: 10px;">
        <p class="span12">
            <a href="#menu" class="side-menu-link btn btn-mini" title="Click for sub-menu">
                <i class="icon-th"></i>
            </a>
        </p>
    </div>

    <div class="col-sm-3">
        <div id="wrap" class="row-fluid wrap">
            
            <div class="sidenav">
                
                <ul class="nav nav-pills nav-stacked">
                    <li><a href="/java">Overview</a></li>
                    <li><a href="/java/get-started#anchor">Get Started</a></li>
                    <li><a href="/java/features#anchor">Features</a></li>
                    <li><a href="/java/demos#anchor">Demos</a></li>
                    <li><a href="/java/examples#anchor">Examples</a></li>
                    <li><a href="/java/tutorials#anchor">Tutorials</a></li>
                    <li><a href="/java/releases#anchor">Releases</a></li>
                    <li><a href="/java/docs#anchor">Docs</a></li>
                </ul>
            </div>
        </div>
    </div>

    
    <section class="col-sm-9">
        

<script>
    window.addEventListener('load', function() {
        $("table").addClass("table table-hover");
    });
</script>

<h2 id="build-a-custom-renderable">Build a Custom Renderable</h2>

<p>This tutorial shows how to implement a custom renderable that draws a cube centered on a geographic position. It is intended for developers familiar with OpenGL, who would like to implement a custom WorldWind Renderable. It may be helpful to follow along with the completed tutorial on <a href="https://github.com/NASAWorldWind/WorldWindJava/blob/develop/src/gov/nasa/worldwindx/examples/tutorial/Cube.java">GitHub</a>.</p>

<h2 id="contents">Contents</h2>

<ul>
<li><a href="#how">How WorldWind Draws a Scene</a></li>
<li><a href="#implementing">Implementing Renderable</a></li>
<li><a href="#drawstate">Managing Drawing State</a></li>
<li><a href="#orienting">Orienting the Cube</a></li>
<li><a href="#draw">Drawing the Cube</a></li>
<li><a href="#picking">Picking</a></li>
<li><a href="#ordered">Ordered Rendering</a></li>
<li><a href="#visibility">Determining if the Cube is Visible</a></li>
<li><a href="#together">Putting it all together</a></li>
</ul>

<h2 id="a-name-how-a-how-worldwind-draws-a-scene"><a name="how"></a>How WorldWind Draws a Scene</h2>

<p>When WorldWind renders a frame, the SceneController sets up the global drawing state, and then asks each Layer in the Model to render itself. Most WorldWind shapes implement the Renderable interface. Renderables can be placed on a RenderableLayer, and will be rendered when the layer is rendered.</p>

<p>Rendering the scene consists of several stages:</p>

<ol>
<li>The SceneController draws the scene in picking mode. &ldquo;Picking&rdquo; is the process of determining which object in a 3D scene has been selected. During picking, each object is drawn in a unique color. The SceneController looks at the color under the cursor to determine the top object. This approach is described in the OpenGL Programming Guide. We will discuss picking further in the Picking section of this tutorial.</li>
<li>The SceneController draws the scene in normal rendering mode. Each Renderable will either draw itself, or add an ordered renderable version of itself to the DrawContext&rsquo;s ordered renderable list to be rendered later.</li>
<li>OrderedRenderables are sorted by eye distance, and then drawn back to front. We will discuss ordered rendering later in this tutorial.</li>
</ol>

<p>See the <a href="/java/tutorials/concepts/">Concepts</a> article of the Tutorial section for more information on the architecture of WorldWind.</p>

<h2 id="a-name-implementing-a-implementing-renderable"><a name="implementing"></a>Implementing Renderable</h2>

<p>To draw a cube, we&rsquo;ll write a class that implements Renderable. This object can be added directly to a RenderableLayer.</p>

<pre><code class="language-java">class Cube implements Renderable
{
    protected Position position;
    protected double size;

    public Cube(Position position, double sizeInMeters)
    {
        this.position = position;
        this.size = sizeInMeters;
    }

    public void render(DrawContext dc)
    {
        // 1) Set up drawing state
        // 2) Apply transform to position cube
        // 3) Draw the cube
        // 4) Restore drawing state to default
    }
}
</code></pre>

<h2 id="a-name-drawstate-a-managing-drawing-state"><a name="drawstate"></a>Managing Drawing State</h2>

<p>Before drawing the cube, we need to set up the OpenGL drawing state. We&rsquo;ll do this in a method called beginDrawing. Any state that we change from the WorldWind default must be restored after rendering the cube, or it will cause other objects to render incorrectly. DrawContext.getGL provides access to the OpenGL context that we&rsquo;ll use for drawing.</p>

<pre><code class="language-java">protected void beginDrawing(DrawContext dc)
{
    GL2 gl = dc.getGL().getGL2();

    int attrMask = GL2.GL_CURRENT_BIT | GL.GL_COLOR_BUFFER_BIT;
    gl.glPushAttrib(attrMask);

    if (!dc.isPickingMode())
        dc.beginStandardLighting();
}
</code></pre>

<p>Any state that we change must be restored after rendering:</p>

<pre><code class="language-java">protected void endDrawing(DrawContext dc)
{
    GL2 gl = dc.getGL().getGL2();

    if (!dc.isPickingMode())
        dc.endStandardLighting();

    gl.glPopAttrib();
}
</code></pre>

<h2 id="a-name-orienting-a-orienting-the-cube"><a name="orienting"></a>Orienting the Cube</h2>

<p>We need set up the OpenGL modelview matrix so that when we draw the cube, it will appear at the correct position on the globe.
computeSurfaceOrientationAtPosition computes a transform matrix that will map the X axis to the vector tangent to the globe and pointing East. The Y axis is mapped to the vector tangent to the Globe and pointing to the North Pole. The Z axis is mapped to the globe normal at specified position.</p>

<p><img src="/img/java/axes.png" alt="axes orientation" /></p>

<p>Local coordinate system with the origin at the cube&rsquo;s center position, and axis aligned with the cardinal directions.</p>

<p>We&rsquo;ll multiply with the active modelview matrix with the surface orientation matrix to position and orient the cube:</p>

<pre><code class="language-java">gl.glMatrixMode(GL2.GL_MODELVIEW);

Matrix matrix = dc.getGlobe().computeSurfaceOrientationAtPosition(this.position);
matrix = dc.getView().getModelviewMatrix().multiply(matrix);

double[] matrixArray = new double[16];
matrix.toArray(matrixArray, 0, false);
gl.glLoadMatrixd(matrixArray, 0);
</code></pre>

<h2 id="a-name-draw-a-drawing-the-cube"><a name="draw"></a>Drawing the Cube</h2>

<p>The method below that will draw a cube one unit on each side, centered on the origin. This method uses OpenGL immediate mode for simplicity, but real applications should use vertex arrays or vertex buffer objects for best performance.</p>

<pre><code class="language-java">protected void drawUnitCube(DrawContext dc)
{
    // Vertices of a unit cube, centered on the origin.
    float[][] v = {{-0.5f, 0.5f, -0.5f}, {-0.5f, 0.5f, 0.5f}, {0.5f, 0.5f, 0.5f}, {0.5f, 0.5f, -0.5f}, {-0.5f, -0.5f, 0.5f}, {0.5f, -0.5f, 0.5f}, {0.5f, -0.5f, -0.5f}, {-0.5f, -0.5f, -0.5f}};

    // Array to group vertices into faces
    int[][] faces = {{0, 1, 2, 3}, {2, 5, 6, 3}, {1, 4, 5, 2}, {0, 7, 4, 1}, {0, 7, 6, 3}, {4, 7, 6, 5}};

    // Normal vectors for each face
    float[][] n = {{0, 1, 0}, {1, 0, 0}, {0, 0, 1}, {-1, 0, 0}, {0, 0, -1}, {0, -1, 0}};

    GL2 gl = dc.getGL().getGL2();

    // Use OpenGL immediate mode for simplicity. Real applications should use
    // vertex arrays or vertex buffer objects for best performance.
    gl.glBegin(GL2.GL_QUADS);
    try
    {
        for (int i = 0; i &lt; faces.length; i++)
        {
            gl.glNormal3f(n[i][0], n[i][1], n[i][2]);

            for (int j = 0; j &lt; faces[0].length; j++)
            {
                gl.glVertex3f(v[faces[i][j]][0], v[faces[i][j]][1], v[faces[i][j]][2]);
            }
        }
    }
    finally
    {
        gl.glEnd();
    }
}
</code></pre>

<p>How this method works is beyond the scope of this tutorial. See one of the excellent <a href="https://open.gl/">OpenGL tutorials</a> if you need a refresher. Using the drawUnitCube method, we can implement render. We apply a scale to make the unit cube the correct size.</p>

<pre><code class="language-java">public void render(DrawContext dc)
{
    this.beginDrawing(dc);
    try
    {
        GL2 gl = dc.getGL().getGL2();
        gl.glScaled(this.size, this.size, this.size);
        this.drawUnitCube(dc);
    }
    finally
    {
        this.endDrawing(dc);
    }
}
</code></pre>

<p><img src="/img/java/cube-correct-orientation.png" alt="Cube Oriented to the Surface" /></p>

<h2 id="a-name-picking-a-picking"><a name="picking"></a>Picking</h2>

<p>We&rsquo;ve implemented code to draw the cube during normal rendering, but we still need to handle selection, or picking. During picking, we need to draw the cube using a unique color, and tell WorldWind that if this color is under the cursor, then the cube is the selected object.</p>

<pre><code class="language-java">protected PickSupport pickSupport = new PickSupport();

public void render(DrawContext dc)
{
    GL2 gl = dc.getGL().getGL2();
    this.beginDrawing(dc);
    try
    {
        if (dc.isPickingMode())
        {
            Color pickColor = dc.getUniquePickColor();
            this.pickSupport.addPickableObject(pickColor.getRGB(), this, this.position);
            gl.glColor3ub((byte) pickColor.getRed(), (byte) pickColor.getGreen(),
                (byte) pickColor.getBlue());
        }

        gl.glScaled(this.size, this.size, this.size);
        this.drawUnitCube(dc);
    }
    finally
    {
        this.endDrawing(dc);
    }
}
</code></pre>

<p><img src="/img/java/picking1.png" alt="Normal and Pick Rendered Cube" /></p>

<p>The image on the left shows a scene drawn in normal rendering mode. The image on the right shows the scene drawn for picking. Each object in the scene is drawn in a unique color. The SceneController looks at the color under the cursor to determine the selected object.</p>

<h2 id="a-name-ordered-a-ordered-rendering"><a name="ordered"></a>Ordered Rendering</h2>

<p>Our code so far renders the cube at the correct position. However, it does not handle transparency or 2D mode correctly. Let&rsquo;s see what happens if we use our Cube class to draw two cubes. The red cube appears transparent, but you can&rsquo;t see the blue cube through the red cube. Instead you see the terrain behind the blue cube. In order to correct this problem, we need to implement the OrderedRenderable interface. An OrderedRenderable is a Renderable that can tell the SceneController how far it is from the eye point. The SceneController uses this information to draw ordered renderables in a back-to-front order, so that the objects blend correctly.</p>

<table>
<thead>
<tr>
<th>No Ordered Rendering</th>
<th>Ordered Rendering</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="/img/java/cube-incorrect-transparency1.png" alt="No Ordered Rendering" /></td>
<td><img src="/img/java/cube-correct-transparency2.png" alt="Ordered Rendering" /></td>
</tr>

<tr>
<td>Transparency is incorrect. The blue cube should be visible through the red cube.</td>
<td>Implementing OrderedRenderable causes the cube to render correctly.</td>
</tr>
</tbody>
</table>

<p>To implement ordered rendering we need to create an internal class that implements OrderedRenderable&rsquo;s methods: getDistanceFromEye, render and pick. We also need to divide our render method into two parts:</p>

<ol>
<li>Add the cube to the ordered renderable queue during normal rendering.</li>
<li>Draw the cube during ordered rendering.</li>
</ol>

<p>In order to determine eye distance we need to know the Cartesian positions of the eye and the cube. The Vec4 class represents a point in Cartesian space. The View can tell us the position of the eye. Globe.computePointFromPosition can compute the Cartesian position of the cube&rsquo;s center. Vec4.distanceTo3 can calculate the distance between the two:</p>

<pre><code class="language-java">Vec4 placePoint = dc.getGlobe().computePointFromPosition(this.position);
double eyeDistance = dc.getView().getEyePoint().distanceTo3(placePoint);
</code></pre>

<p>Here are the changes required to support ordered rendering:</p>

<pre><code class="language-java">protected class OrderedCube implements OrderedRenderable
{
    /** Cartesian position of the cube */
    protected Vec4 placePoint;
    /** Distance from the eye point to the cube. */
    protected double eyeDistance;
    /** The cube's Cartesian bounding extent. */
    protected Extent extent;

    public double getDistanceFromEye()
    {
        return this.eyeDistance;
    }

    public void pick(DrawContext dc, Point pickPoint)
    {
        // Use same code for rendering and picking.
        this.render(dc);
    }

    public void render(DrawContext dc)
    {
        Cube.this.drawOrderedRenderable(dc, Cube.this.pickSupport);
    }
}

public void render(DrawContext dc)
{
    // Render is called twice, once for picking and once for rendering. In both cases an OrderedCube is added to
    // the ordered renderable queue.

    OrderedCube orderedCube = this.makeOrderedRenderable(dc);

    // Add the cube to the ordered renderable queue. The SceneController sorts the ordered renderables by eye
    // distance, and then renders them back to front.
    dc.addOrderedRenderable(orderedCube);
}

protected OrderedCube makeOrderedRenderable(DrawContext dc)
{
    OrderedCube orderedCube = new OrderedCube();

    // Convert the cube's geographic position to a position in Cartesian coordinates. If drawing to a 2D
    // globe ignore the shape's altitude.
    if (dc.is2DGlobe())
    {
        orderedCube.placePoint = dc.getGlobe().computePointFromPosition(this.position.getLatitude(),
            this.position.getLongitude(), 0);
    }
    else
    {
        orderedCube.placePoint = dc.getGlobe().computePointFromPosition(this.position);
    }

    // Compute the distance from the eye to the cube's position.
    orderedCube.eyeDistance = dc.getView().getEyePoint().distanceTo3(orderedCube.placePoint);

    return orderedCube;
}

protected void drawOrderedRenderable(DrawContext dc, PickSupport pickCandidates)
{
    this.beginDrawing(dc);
    try
    {
        GL2 gl = dc.getGL().getGL2();
        if (dc.isPickingMode())
        {
            Color pickColor = dc.getUniquePickColor();
            pickCandidates.addPickableObject(pickColor.getRGB(), this, this.position);
            gl.glColor3ub((byte) pickColor.getRed(), (byte) pickColor.getGreen(),
                          (byte) pickColor.getBlue());
        }

        gl.glScaled(this.size, this.size, this.size);
        this.drawUnitCube(dc);
    }
    finally
    {
        this.endDrawing(dc);
    }
}
</code></pre>

<h2 id="a-name-visibility-a-determining-if-the-cube-is-visible"><a name="visibility"></a>Determining if the Cube is Visible</h2>

<p>What we&rsquo;ve done so far is enough to draw the cube. But our implementation will draw the cube even if it is not visible in the active view. One of the most effective ways to boost performance is to not draw shapes that are not visible. We&rsquo;ll add some code that checks to make sure that the cube is visible in the active viewport, and that the cube will appear larger than a single pixel.</p>

<p>First we need to create an Extent to represent the volume enclosed by the cube. The extent does not need to match the geometry of a renderable exactly, but it should completely enclose the geometry. For simplicity, we&rsquo;ll use a Sphere that surrounds the cube:</p>

<pre><code class="language-java">protected Extent extent;

protected void makeOrderedRenderable(DrawContext dc)
{
    ...
    this.placePoint = dc.getGlobe().computePointFromPosition(this.position);
    this.extent = new Sphere(this.placePoint, Math.sqrt(3.0) * this.size / 2.0);
    ...
}
</code></pre>

<p>Now that we have an extent, we can determine if the extent intersects the view frustum. If it does not, then the cube is not visible and there is no need to draw it. In picking mode, we can test against the pick frustrums, which enclose only a small volume around the cursor.</p>

<pre><code class="language-java">protected boolean intersectsFrustum(DrawContext dc)
{
    if (this.extent == null)
        return true; // don't know the visibility, shape hasn't been computed yet

    if (dc.isPickingMode())
        return dc.getPickFrustums().intersectsAny(this.extent);

    return dc.getView().getFrustumInModelCoordinates().intersects(this.extent);
}
</code></pre>

<p>Finally, we&rsquo;ll add checks to avoid drawing the cube if it is not visible, or if it is smaller than one pixel.</p>

<pre><code class="language-java">public void render(DrawContext dc)
{
    // Render is called twice, once for picking and once for rendering. In both cases an OrderedCube is added to
    // the ordered renderable queue.

    OrderedCube orderedCube = this.makeOrderedRenderable(dc);

    if (orderedCube.extent != null)
    {
        if (!this.intersectsFrustum(dc, orderedCube))
            return;

        // If the shape is less that a pixel in size, don't render it.
        if (dc.isSmall(orderedCube.extent, 1))
            return;
    }

    // Add the cube to the ordered renderable queue. The SceneController sorts the ordered renderables by eye
    // distance, and then renders them back to front.
    dc.addOrderedRenderable(orderedCube);
}
</code></pre>

<h2 id="a-name-together-a-putting-it-all-together"><a name="together"></a>Putting it all Together</h2>

<p>We&rsquo;ve seen how to draw, position, and orient a cube in WorldWind. We&rsquo;ve also seen how to implement the cube as an OrderedRenderable, how to handle picking, and how to determine if the cube is visible. The full cube class is available in the WorldWind distribution at gov.nasa.worldwindx.examples.tutorial.Cube.</p>

    </section>
</div>




    <div class="push"></div>
    <script type="text/javascript" src="/js/event-tracking.js"></script>

    </div>
    <br/>
    <br/>
    </body>
    <div>
    <footer id="fh5co-footer" class="overlay fh5co-bg">
    <div class="overlay"></div>
    <div class="container">
        <div class="row row-pb-md">
            <div class="col-md-2 fh5co-widget">
                <a href="/"><h3 class="text-center">Home</h3></a>
            </div>
            <div class="col-md-2 fh5co-widget">
                <a href="https://github.com/WorldWindLabs"><h3 class="text-center">Apps</h3></a>
            </div>
            <div class="col-md-2 fh5co-widget">
                <a href="https://github.com/NASAWorldWind"><h3 class="text-center">Source Code</h3></a>
            </div>
            <div class="col-md-2 fh5co-widget">
                <a href="/about"><h3 class="text-center">About</h3></a>
            </div>
            <div class="col-md-2 fh5co-widget">
                <a href="/contact"><h3 class="text-center">Contact</h3></a>
            </div>
            <div class="col-md-2 fh5co-widget">
                <a href="/blog/roadmap"><h3 class="text-center">Blog</h3></a>
            </div>
            </div>
        </div>
</footer>
    </div>

</html>